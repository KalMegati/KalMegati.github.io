---
layout: post
title:      "Sendoff - Journey"
date:       2020-07-31 09:21:27 +0000
permalink:  sendoff_-_journey
---


Journey is a 2012 single-player adventure video game by thatgamecompany and Santa Monica Studios. You play a faceless, wordless wanderer traveling through the desert with only seemingly only a couple of tools at your disposal: you can jump, and you can "ping" (a close burst of sound akin to singing). The ping does not seem to have any use initially, but soon you run into other characters in the game. If you ping close to these wanderers, they will likely ping back, revealing the purpose of the pings: any wanderers nearby you when you ping will have their jump improved, allowing them to reach higher locations. Two wanderers pinging in sync can greatly increase both of their vertical reach. Still, these wanderers might not always operate in immediately helpful ways. They might go in directions other than your goal or not even ping when first met until you ping near them multiple times. This is a pretty strange choice for NPC companions in a puzzle game; why not have their AI operate consistently based on your inputs? Let's get back to that later.

I started my own journey into coding in the autumn of 2019 with the Flatiron School's Online Software Engineering course. This was not however the beginning of my interest in coding: that began a fews years ago at the end of college, when I took Programming 101 to fill out my last semester schedule. It was straightforward enough thankfully, as I was just about burnt out on the college experience and did not quite have it in me to take a passionate interest. I raised my hand to answer prompts frequently during lectures, but rarely did I ever actually interact with my classmates. The experience was simply enough to plant the seed of interesting within me: "this seems fun, I wouldn't mind doing this for a job".

What I expected of my Flatiron cohort was a straightforward coding bootcamp. I mean, I'd never actually taken one of those before, but it sounded like it would be similar to Programming 101: follow the lessons, do the assignments, just keep your eyes on the code in front of you and you'll do fine. I learned quickly that this was a misjudgement. The introductory announcements and cohort meetings were much less about actual code and much more about defining the nature of the cohort. The coaches spoke most proudly of the efforts and resources dedicated to making the cohort feel not simply like a classroom setting, but a full campus experience. My cohortmates were not just other people following the lectures: they are my classmates.

This extended into weekly study groups and pair programming. I distinctly remember one group session deep in the winter when we collectively side-tracked from the prompt of the week to instead challenge the `pluralizer` gem with increasingly esoteric word forms, discussing how intriguing it was that it could reliably catch some rules ("scarf" > "scarves" and also "knife" > "knives") but not others (many exception cases are not made and so it will return "gooses" and "mooses"). Appreciable no doubt, but was it necessary? Code is code after all. Couldn't someone learn this all independently by just following the rules? I don't really think so anymore.

Code (as I've learned through my other posts) is heavily influenced by perspective. I might use an object where another uses a simple string, and yet others might even use a switch-case function. Or to name a specific example, I spent a great deal of time working on Tabula Rasa trying to figure out how to make user accounts work with a Rails API. Normally for a Rails back-end you generate it with an `--api` tag, so that fetch requests will not result in accreditation errors. However, `--api` will also remove certain necessary inclusions from the back-end that allow it to maintain the sessions hash, which I planned on using to keep a record of the current user. I struggled trying to retrace the script and make all the necessary inclusions, but I kept running into the issue of either having not all the necessary inclusions to maintain a session, or having enough inclusions that my fetches would be denied.

It was during project show-and-tell that I learned how some of my cohortmates implemented user accounts: they generated their back-end without the `--api` tag, and then included extra arguments to the fetch request that would allow it to fulfill the credentials. The rub here was that I never crossed this information in my own research. I had scoured the documentation looking for an answer that I couldn't find because what I was looking for was "how can I make sessions work with an API", rather than "how can I make fetch requests to a non-API". The crucial component wasn't a lack of information, but rather working from a less advantageous perspective.

And this how coding works in the professional setting, isn't it? I've heard the often repeated self-deprecating notion from programmers that the bulk of their job is just searching for answers that other people have found. This new normal marries official and informal, where we might find our answers on reference documents with no less difficulty or reliability than we do on anonymous forum posts like stackexchange. What are the gems and packages we install if not cross-time collaboration with their creators? "If I have seen further it is by standing on the shoulders of Giants," so wrote Isaac Newton, himself learning the phrase from older thinkers such as Berard of Chartres.

You see, Journey is not really a single-player game. There are no non-player characters to interact with: every other wanderer you meet on your Journey is not an AI but rather another player, making their own way through the game. The lack of any clear communication beyond the ping conceals this, but in fact those other players are receiving help from you just as you receive it from them. When you ping near another wanderer, that might be the first time they even realize what the function of the ping is, and once they know it they can then go on to share that knowledge of the ping with other new players. My pie chart is sliced up into what I can do and what I can't, much like yours. But when we collaborate, those "cans" overlap, while the "can'ts" are overridden. What we can't do is smaller than what I can't do, and it gets smaller still the more perspectives we gather.

Learning with Flatiron was not simply my journey. This was *our* journey.

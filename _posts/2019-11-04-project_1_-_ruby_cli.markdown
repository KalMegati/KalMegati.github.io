---
layout: post
title:      "PROJECT 1 - RUBY CLI"
date:       2019-11-04 18:16:00 +0000
permalink:  project_1_-_ruby_cli
---


Welcome to my Cluttered Workbench. For now at least this is the first thing on my blog so until I have a formal welcome written up, I’ll start it here. I wonder if maybe I won’t be able to edit this out once that does exist? Oh well.
My first project for the Flatiron School’s Online Software Engineering course is to build a Ruby CLI; that is, a Ruby application using a Command-Line Interface. My application is a walkthrough for setting up the basics of a Pathfinder character, a first step for what I plan to make a much larger program designed to take a player through the entirety of the character building process.

**Why Pathfinder 2**

The reason that I have resolved to learn programming is to design for accessibility. In particular, I want to make applications that improve or simplify the learning experience of roleplaying games. I would make a database so guided and parsed that all a prospective player would need to do is describe their fantasy, and the computer would speak back all the game mechanics they can use to create it, without requiring hours of shuffling through pages to build the adventurer they want to play. There’s also the unavoidable point to make about the latest iteration of Dungeon and Dragons, 5th edition, seeing a far larger player base than ever before owing largely to its design philosophy placing a large emphasis on the game accessible to tabletop newcomers. And intentional or not, this also recaptured the attention of many who could handle the convolution of older editions, but agreed that the game was much better anyway with that convolution removed. 
And DnD’s popularity means that the demand for its accessibility is soaring; in the five years of the system’s life to date there are many tools built to guide players through the process of the most famous rpg ever. But what about other games? Less popular games that don’t have such a sprawling fanbase such that someone is pushed to create a convenience application, and relatedly do not have the conveniences necessary to gaining a large fanbase? This brings us to the subject of this program, Pathfinder 2nd Edition.
Pathfinder 2 was released at the end of Summer 2019; at the time of this writing, it has been about 3 months. And the game has a considerable reputation to both live up to an overcome: Pathfinder 1 is a great deal more complicated than DnD 5, and while Pathfinder 2 was built to streamline that, it still intentionally remains a more complex system than DnD 5. This is exactly the kind of situation I want to be in when designing an application of this sort. When is a better time to cater to newcomers than a time when *everyone* is a newcomer?
I did not consider building an application for DnD, as I cannot imagine it be necessary among the hundreds of such that exist already. I could have built an application for Pathfinder 1, but at over 10 years old it simply has so much disparate content to be addressed that finding a place to start would have been difficult. I would also lack a rather crucial perspective on Pathfinder 1; having played the system for so long, what it is that I take for granted as obvious that a newcomer might not? With Pathfinder 2, I had a certainty that I could determine what resources would be useful to a newcomer, because I was a newcomer myself.
And in a pragmatic sense, the sense of “I want this program I build for my course to not be too difficult”, Pathfinder 2 has the advantage of making things *code*-friendly. The game heavily features Keywords, descriptors used to relate certain options and group them into an overlapping flowchart of mechanics. Having consistent recurring elements like this have made it easy to automate scraping protocols, and I imagine this will only continue to prove true as I expand the functions of the builder.
One example lies in the abilities that characters can access. In Pathfinder 1, the rogue has “Rogue Talents” and the fighter has “Fighter Bonus Feats”, so you might think there is at least a consistency in “{Class Name} {Thematic Word}”, but it gets even more arbitrary as the barbarian has “Rage Powers” and the alchemist has “Discoveries”. In Pathfinder 2, these all become “Feats”: Rogue Feats, Barbarian Feats, Fighter Feats, Alchemist Feats. The consistent naming makes these now more clearly recognizable as analogous concepts, to a player but also especially to a computer, which can now follow the simple logic of “{Class} has access to {Class} Feats” (pardon my pseudocode).

**How Pathfinder 2**

Or more understandably, “how does Pathfinder 2 do it?” I was making a program for the purpose of guiding users through Pathfinder 2’s character creation process, so how does Pathfinder 2 organize its character creation? With a simple ABC pneumonic: Ancestry, Background, Class. It follows chronologically: the circumstances of your character’s birth (Ancestry), how your character was raised and trained until now (Background), and finally what your character will be defined by going forward during the game (Class). Pathfinder 2’s design elements of ordered pneumonics and consistent terminology ended up being quite formative of my own design philosophy in writing my code.
I first decided to reflect the ABC convention in the naming of my classes. The scraper class, grabbing information from Archives of Nethys, is “Archivist”. The CLI-presenting class, taking commands from the user and relays them to the rest of the program, is “Commander” (bit of a stretch there, but I can’t think of a better C word). Between A and C is B, the class that builds characters based on commands from Commander referencing information from Archivist, “Builder”. I think there’s a point to be made about artistry in coding, and that point has probably already been made by someone much more versed in both of those things than I am (and if not, well I was thinking of writing that post before I finished this course anyway).
Look further into my code and you will notice that generated characters, the objects of Builder, do not have :ancestry, :background, or :class attributes as you might expect; they instead have the attributes :ancestries, :backgrounds, and :classes. This intentionally matches the attributes of Archivist; in earlier builds, Archivist’s attributes were pluralized and Builder’s were singular, and Builder had a method (#plu_aspect) that consisted of many conditionals designed purely to have its singular attributes point towards the pluralized attributes of Archivist. If I just made the attributes the same instead, I could bypass this conditional (bypassing a potential bug source at that).
But why the plural instead of the singular? Well the URLs use the plurals as well (https://2e.aonprd.com/Ancestries.aspx). So if my attributes were plural then I could simply convert the symbols to strings and capitalize them, rather than needing to pluralize them as well (note that “ancestries”, “backgrounds”, and “classes” all follow different structure shifts for determining their plural from their singular; this complication was the reason that #plu_aspect would otherwise be needed).
There’s also a much bigger reason to avoid the singular that I didn’t realize until it was explained to me: having a :class readable attribute would mean having a #class instance method…which would end up overwriting or interfering with Ruby’s #class method, which returns the class of the object it acts upon. As in like, the Ruby class, not the Pathfinder class. It is kind of neat how Ruby and Pathfinder use the terms analogously, but less neat that this analogy actually makes the overlap an even bigger issue than it would be otherwise. So yeah, plural attributes.
And on recurring terminology, many of my methods, across all classes, have their arguments designated as “option” and “aspect”. Every time those words are used is consistent: “aspect’ is filled by :ancestries, :backgrounds, or :classes, while “option” refers to the options available for each aspect. Like most of my decisions this will not manifest in any particular way that affects the user, but is important to my goals going forward. If I plan on adding much more functionality to this program, it will be helpful to be able to reference previously coded methods and immediately recognize what they are asking for.

**Where Pathfinder 2**

…is going from here. That’s the rest of the subtitle.
My application does not yet track how strong or how smart a character is, though that is a crucial part of the creation process (happening concurrently with each step of ABC in fact). Characters are denoted as being in x class with y background, but the mechanical effects that those options entail are not yet relayed to the user. Pathfinder 2 characters are not simply made, they also gain more abilities as the game is played, so I will need a way for a player to increment a previously built character upwards (handily, it seems that our next topic in the course will be centered on databases; I imagine I’ll be storing characters there between instances of Commander). And bringing these ideas together, a character must meet the requirements to obtain an ability, so a character object must be able to cross-reference its own stat block attribute with the requirements of the ability. So will I make each ability an object, with requirements as attributes? This thought came to me only as I was writing this paragraph, I’ll need to think on it.
Along with future updates is future-proofing, and ultimately this is a concern that will exist until Pathfinder 2 stops producing content. As of yet, at no point in the pages I scrape are the singulars of ABC used in a way that I need to refer to. However there is information on the pages that is delineated by using “Ancestry” singular as a keyword (and likewise for “Background” and “Class”, and so I will eventually need to uncomment #plu_aspect, using it to translate between plural symbols ABC and singular strings “Ancestry”, “Background”, and “Class”. The Ruby#class vs Pathfinder#class overlap is certainly going to rear its head again multiple times before I even reach a version 1.0. And perhaps most concerning, what happens when there are so many options that an aspect must span multiple separate HTML documents? Well obviously, I’ll need to find a way to automate the scraper to recognize how many pages it will need to scrape, and how to locate each of them.
The Advanced Player’s Guide, a large content expansion book, releases early in 2020, carrying with it many new ancestries, backgrounds, classes, and tons of options that my program does not even account for yet.
I think the crucial test of p2e_builder will be if it can accept that content in its contemporary state. If it cannot…I guess I’ll refactor where I need to and keep pushing. And if another expansion ends up demanding a complete rebuild from square zero? I believe I’m willing to say “yeah I’ll do it!”, but I don’t think I’ll need to. I’m confident in the generality and applicability of the code I’ve written, and in my practices building it. The only unknown now is how an update will change the site layout, thus changing the demands of my scraper, and if the commitment to consistency thus far is any indication, I will be able to determine based on expansion #1 just how an expansion will change the site. And then I’ll be able to say with certainty that when expansion #2 comes to Pathfinder 2, p2e_builder will be ready.

Check it out at https://rubygems.org/gems/p2e_builder. It just needs you and your imagination.

